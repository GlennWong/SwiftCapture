import Foundation
import ArgumentParser

@main
struct ScreenRecorderCommand: AsyncParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "screenrecorder",
        abstract: "Professional screen recording tool for macOS using ScreenCaptureKit",
        discussion: """
        \(HelpFormatter.usageExamples)
        \(HelpFormatter.detailedHelp)
        \(HelpFormatter.troubleshooting)
        """,
        version: "2.0.0",
        helpNames: [.short, .long, .customLong("help")]
    )
    
    // MARK: - Duration Control
    @Option(name: [.short, .long], help: "Recording duration in milliseconds (default: 10000)")
    var duration: Int = 10000
    
    // MARK: - Output Options
    @Option(name: [.short, .long], help: "Output file path (default: current directory with timestamp)")
    var output: String?
    
    // MARK: - Screen/Area Selection
    @Option(name: [.short, .long], help: "Recording area in format x:y:width:height (default: full screen)")
    var area: String?
    
    @Flag(name: [.customShort("l"), .customLong("screen-list")], help: "List all available screens with their indices")
    var screenList: Bool = false
    
    @Option(name: [.short, .long], help: "Screen index to record from (1=primary, 2+=secondary)")
    var screen: Int = 1
    
    // MARK: - Application Recording
    @Flag(name: [.customShort("L"), .customLong("app-list")], help: "List all running applications")
    var appList: Bool = false
    
    @Option(name: [.customShort("A"), .long], help: "Application name to record (instead of screen)")
    var app: String?
    
    // MARK: - Audio Options
    @Flag(name: [.short, .long], help: "Enable microphone recording")
    var enableMicrophone: Bool = false
    
    // MARK: - Advanced Recording Options
    @Option(help: "Frame rate: 15, 30, or 60 fps (default: 30)")
    var fps: Int = 30
    
    @Option(help: "Quality preset: low, medium, or high (default: medium)")
    var quality: String = "medium"
    
    @Option(help: "Output format: mov or mp4 (default: mov)")
    var format: String = "mov"
    
    @Flag(help: "Show cursor in recording")
    var showCursor: Bool = false
    
    @Option(help: "Countdown seconds before recording starts (default: 0)")
    var countdown: Int = 0
    
    // MARK: - Preset Management
    @Option(help: "Save current settings as a named preset")
    var savePreset: String?
    
    @Option(help: "Load settings from a saved preset")
    var preset: String?
    
    @Flag(help: "List all saved presets")
    var listPresets: Bool = false
    
    @Option(help: "Delete a saved preset")
    var deletePreset: String?
    
    // MARK: - Validation
    func validate() throws {
        // Check system requirements first
        guard #available(macOS 12.3, *) else {
            throw ValidationError.systemRequirementsNotMet()
        }
        
        // Validate individual parameters
        try validateDuration()
        try validateFPS()
        try validateQuality()
        try validateFormat()
        try validateScreen()
        try validateCountdown()
        try validateArea()
        
        // Validate argument combinations and conflicts
        try validateArgumentCombinations()
    }
    
    private func validateDuration() throws {
        if duration < 100 {
            throw ValidationError.invalidDuration(duration)
        }
    }
    
    private func validateFPS() throws {
        if ![15, 30, 60].contains(fps) {
            throw ValidationError.invalidFPS(fps)
        }
    }
    
    private func validateQuality() throws {
        if !["low", "medium", "high"].contains(quality.lowercased()) {
            throw ValidationError.invalidQuality(quality)
        }
    }
    
    private func validateFormat() throws {
        if !["mov", "mp4"].contains(format.lowercased()) {
            throw ValidationError.invalidFormat(format)
        }
    }
    
    private func validateScreen() throws {
        if screen < 1 {
            throw ValidationError.invalidScreen(screen)
        }
    }
    
    private func validateCountdown() throws {
        if countdown < 0 {
            throw ValidationError.invalidCountdown(countdown)
        }
    }
    
    private func validateArea() throws {
        guard let areaString = area else { return }
        
        let components = areaString.split(separator: ":")
        guard components.count == 4 else {
            throw ValidationError.invalidAreaFormat(areaString)
        }
        
        for component in components {
            guard let value = Int(component), value >= 0 else {
                throw ValidationError.invalidAreaCoordinates(areaString)
            }
        }
        
        // Additional validation: ensure width and height are positive
        let values = components.compactMap { Int($0) }
        if values.count == 4 && (values[2] <= 0 || values[3] <= 0) {
            throw ValidationError(
                "Invalid area dimensions: width and height must be greater than 0.",
                suggestion: "Ensure width (3rd value) and height (4th value) are positive, like --area 0:0:1920:1080"
            )
        }
    }
    
    private func validateArgumentCombinations() throws {
        // Check for conflicting screen/app options
        if app != nil && (screen != 1 || area != nil) {
            throw ValidationError(
                "Application recording conflicts with screen/area selection.",
                suggestion: "Use either --app for application recording OR --screen/--area for screen recording, but not both"
            )
        }
        
        // Check for conflicting list operations
        let listOperations = [screenList, appList, listPresets].filter { $0 }
        if listOperations.count > 1 {
            throw ValidationError(
                "Multiple list operations specified. Only one list operation allowed at a time.",
                suggestion: "Use only one of: --screen-list, --app-list, or --list-presets"
            )
        }
        
        // Check for conflicting preset operations
        let presetOperations = [savePreset != nil, preset != nil, deletePreset != nil].filter { $0 }
        if presetOperations.count > 1 {
            throw ValidationError(
                "Multiple preset operations specified. Only one preset operation allowed at a time.",
                suggestion: "Use only one of: --save-preset, --preset, or --delete-preset"
            )
        }
        
        // Check if recording options are used with list operations
        if screenList || appList || listPresets {
            let hasRecordingOptions = duration != 10000 || output != nil || area != nil || 
                                    screen != 1 || app != nil || enableMicrophone || 
                                    fps != 30 || quality != "medium" || format != "mov" || 
                                    showCursor || countdown != 0
            
            if hasRecordingOptions {
                throw ValidationError(
                    "Recording options cannot be used with list operations.",
                    suggestion: "Use list operations alone to view available options, then run recording command separately"
                )
            }
        }
        
        // Check if preset deletion is used with other options
        if deletePreset != nil {
            let hasOtherOptions = duration != 10000 || output != nil || area != nil || 
                                screen != 1 || app != nil || enableMicrophone || 
                                fps != 30 || quality != "medium" || format != "mov" || 
                                showCursor || countdown != 0 || savePreset != nil || preset != nil
            
            if hasOtherOptions {
                throw ValidationError(
                    "Preset deletion cannot be combined with other options.",
                    suggestion: "Use --delete-preset alone to remove a preset"
                )
            }
        }
        
        // Validate output file extension matches format
        if let outputPath = output {
            let pathExtension = (outputPath as NSString).pathExtension.lowercased()
            if !pathExtension.isEmpty && pathExtension != format.lowercased() {
                throw ValidationError(
                    "Output file extension '\(pathExtension)' doesn't match format '\(format)'.",
                    suggestion: "Either change the file extension to .\(format) or use --format \(pathExtension)"
                )
            }
        }
        
        // Validate preset names contain only allowed characters
        if let presetName = savePreset {
            try validatePresetName(presetName)
        }
        if let presetName = preset {
            try validatePresetName(presetName)
        }
        if let presetName = deletePreset {
            try validatePresetName(presetName)
        }
        
        // Validate countdown range
        if countdown > 60 {
            throw ValidationError(
                "Countdown too long: \(countdown) seconds. Maximum is 60 seconds.",
                suggestion: "Use a shorter countdown like --countdown 5 or --countdown 10"
            )
        }
        
        // Validate reasonable duration limits (warn for very long recordings)
        if duration > 3600000 { // 1 hour
            throw ValidationError(
                "Duration very long: \(duration)ms (\(duration/60000) minutes). This may create very large files.",
                suggestion: "Consider shorter recordings or use --quality low to reduce file size"
            )
        }
        
        // Check for potentially problematic area dimensions
        if let areaString = area {
            let components = areaString.split(separator: ":").compactMap { Int($0) }
            if components.count == 4 {
                let width = components[2]
                let height = components[3]
                
                // Warn about very large recording areas
                if width * height > 4096 * 2160 { // Larger than 4K
                    throw ValidationError(
                        "Recording area very large: \(width)Ã—\(height). This may impact performance.",
                        suggestion: "Consider a smaller area or use --quality low and --fps 15 for better performance"
                    )
                }
                
                // Warn about very small recording areas
                if width < 100 || height < 100 {
                    throw ValidationError(
                        "Recording area very small: \(width)Ã—\(height). Minimum recommended size is 100Ã—100.",
                        suggestion: "Use a larger area like --area 0:0:800:600 for better visibility"
                    )
                }
            }
        }
    }
    
    private func validatePresetName(_ name: String) throws {
        // Check for empty name
        if name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            throw ValidationError.invalidPresetName(name)
        }
        
        // Check for valid characters (letters, numbers, hyphens, underscores)
        let allowedCharacters = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: "-_"))
        if name.rangeOfCharacter(from: allowedCharacters.inverted) != nil {
            throw ValidationError.invalidPresetName(name)
        }
        
        // Check length
        if name.count > 50 {
            throw ValidationError(
                "Preset name too long: '\(name)'. Maximum length is 50 characters.",
                suggestion: "Use a shorter name like 'meeting' or 'demo-setup'"
            )
        }
    }
    
    // MARK: - Main Execution
    func run() async throws {
        do {
            // System requirements are checked in validate() method
            // For now, delegate to the existing ScreenRecorder implementation
            // This will be refactored in later tasks
            
            // Handle list operations first
            if screenList {
                try await handleScreenList()
                return
            }
            
            if appList {
                try await handleAppList()
                return
            }
            
            if listPresets {
                try await handleListPresets()
                return
            }
            
            // Handle preset deletion
            if let presetName = deletePreset {
                try await handleDeletePreset(presetName)
                return
            }
            
            // Show countdown if specified
            if countdown > 0 {
                try await showCountdown()
            }
            
            // For now, call the existing recording function with converted parameters
            // This will be refactored when we implement the new architecture
            if #available(macOS 12.3, *) {
                await callLegacyRecording()
            }
            
        } catch let error as ValidationError {
            // Handle validation errors with formatted output
            print("âŒ \(error.message)")
            if let suggestion = error.suggestion {
                print("ğŸ’¡ \(suggestion)")
            }
            print("")
            print("Use --help for detailed usage information.")
            throw ExitCode.validationFailure
            
        } catch {
            // Handle other errors
            print("âŒ An unexpected error occurred: \(error.localizedDescription)")
            print("ğŸ’¡ Try running with --help for usage information, or check system permissions.")
            throw ExitCode.failure
        }
    }
    
    // MARK: - Handler Methods (Placeholder implementations)
    private func handleScreenList() async throws {
        print("ğŸ“º Available Screens:")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        // This is a placeholder implementation - actual screen detection will be implemented in later tasks
        print("  1. ğŸ’» Primary Display (2560Ã—1440) - Built-in Retina Display")
        print("     Resolution: 2560Ã—1440 @ 60Hz")
        print("     Color Space: P3 Display")
        print("     Status: Active (Primary)")
        print("")
        print("  2. ğŸ–¥ï¸  External Display (1920Ã—1080) - Dell U2415")
        print("     Resolution: 1920Ã—1080 @ 60Hz") 
        print("     Color Space: sRGB")
        print("     Status: Active (Secondary)")
        print("")
        
        print("ğŸ’¡ Usage Examples:")
        print("  screenrecorder --screen 1                    # Record primary display")
        print("  screenrecorder --screen 2                    # Record secondary display")
        print("  screenrecorder --screen 1 --area 0:0:1920:1080  # Record 1080p area on primary")
        print("  screenrecorder --screen 2 --area 0:0:1920:1080  # Record full secondary display")
        print("")
        print("ğŸ“ Note: Screen indices may change when displays are connected/disconnected.")
        print("   Run --screen-list again if your display setup changes.")
    }
    
    private func handleAppList() async throws {
        print("ğŸ“± Running Applications:")
        print("  Safari - Web browser")
        print("  Terminal - Command line interface")
        print("  Finder - File manager")
        print("  System Preferences - System settings")
        print("  Xcode - Development environment")
        print("\nUse --app <name> to record a specific application")
        print("")
        print("ğŸ’¡ Usage:")
        print("  screenrecorder --app Safari        # Record Safari windows")
        print("  screenrecorder --app \"Final Cut Pro\"  # Record app with spaces in name")
        print("")
        print("ğŸ“ Note: Application names are case-sensitive. Use exact names as shown above.")
    }
    
    private func handleListPresets() async throws {
        print("ğŸ’¾ Saved Presets:")
        print("  No presets saved yet")
        print("\nUse --save-preset <name> to save current settings")
        print("")
        print("ğŸ’¡ Usage:")
        print("  screenrecorder --save-preset \"meeting\"     # Save current settings")
        print("  screenrecorder --preset \"meeting\"         # Use saved preset")
        print("  screenrecorder --delete-preset \"meeting\"  # Delete preset")
        print("")
        print("ğŸ“ Note: Presets save all current CLI options for easy reuse.")
    }
    
    private func handleDeletePreset(_ name: String) async throws {
        // This is a placeholder - actual implementation will come in later tasks
        print("ğŸ—‘ï¸  Deleting preset '\(name)'...")
        print("âŒ Preset management not yet implemented.")
        print("")
        print("ğŸ’¡ This feature will be available in a future update.")
        print("   For now, you can use individual CLI options for each recording.")
    }
    
    private func showCountdown() async throws {
        print("ğŸ¬ Recording will start in:")
        for i in (1...countdown).reversed() {
            print("   \(i)...")
            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
        }
        print("ğŸ”´ Recording started!")
    }
    
    @available(macOS 12.3, *)
    private func callLegacyRecording() async {
        // Convert new CLI parameters to legacy format
        let outputPath = generateOutputPath()
        let fullScreen = (area == nil) // If no area specified, use full screen
        
        print("ğŸ“¹ Recording Configuration:")
        print("   Duration: \(Double(duration) / 1000.0) seconds")
        print("   Output: \(outputPath)")
        print("   Screen: \(screen)")
        print("   FPS: \(fps)")
        print("   Quality: \(quality)")
        print("   Format: \(format)")
        print("   Microphone: \(enableMicrophone ? "enabled" : "disabled")")
        print("   Cursor: \(showCursor ? "visible" : "hidden")")
        
        // Call the existing recording function
        await LegacyScreenRecorder.record(
            durationMs: duration,
            outputPath: outputPath,
            fullScreen: fullScreen
        )
    }
    
    private func generateOutputPath() -> String {
        if let customOutput = output {
            return customOutput
        }
        
        // Generate timestamp-based filename
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = formatter.string(from: Date())
        let filename = "\(timestamp).\(format.lowercased())"
        
        return FileManager.default.currentDirectoryPath + "/" + filename
    }
}